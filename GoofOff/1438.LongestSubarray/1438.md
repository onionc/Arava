**题目**：绝对差不超过限制的最长连续子数组
**描述**：一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit。如果不存在满足条件的子数组，则返回 0。

**思路**：没有很巧妙的思路，先取到所有子数组，然后获取min & max,求差值。

**过程：**

**第一版：**

```java
class Solution {
    private int getMax(List<Integer> a){
        return Collections.max(a);
    }
    private int getMin(List<Integer> a){
        return Collections.min(a);
    }

    public int longestSubarray(int[] nums, int limit) {

        int maxLen = 0;
        //List<List<Integer>> subarray = new ArrayList<>();
        // 1. 求出子集（连续的子集）
        for(int i=0; i<nums.length; i++){
            ArrayList<Integer> t = new ArrayList<>();
            for(int j=i; j<nums.length; j++){
                t.add(nums[j]);
                // 2. 求出子集最大最小值的差值（绝对值）
                int v = getMax(t)-getMin(t);
                // 3. 满足v<=limit的最长的序列
                // System.out.printf("%d %d %s %b %b\n", v, maxLen, t, v<limit, maxLen<t.size());
                if(v<=limit && maxLen<t.size()){
                    maxLen = t.size();
                }

                //subarray.add((List)t.clone());
            }
        }

        // System.out.println(subarray);
        return maxLen;
    }
}
```



第四个用例TLE，（进度：35/56）超时是因为使用 Collections.max/min 计算最大最小值，改成手动记录 max min，AC。

**第二版：**

```java
class Solution {

    public int longestSubarray(int[] nums, int limit) {

        int maxLen = 0;
        int max=0;
        int min=0;
        List<List<Integer>> subarray = new ArrayList<>();
        // 1. 求出子集（连续的子集）
        for(int i=0; i<nums.length; i++){
            ArrayList<Integer> t = new ArrayList<>();
            for(int j=i; j<nums.length; j++){
                t.add(nums[j]);
                if(j==i){
                    min=max=nums[j];
                    //size=0;
                }else if(nums[j]<min){
                    min = nums[j];
                }else if(nums[j]>max){
                    max = nums[j];
                }
                // 2. 求出子集最大最小值的差值（绝对值）
                int v=max-min;
                // 3. 满足v<=limit的最长的序列
                if(v<=limit && maxLen<t.size()){
                    maxLen = t.size();
                }
            }
        }

        System.out.println(maxLen);
        return maxLen;
    }
}
```



第五个用例TLE，（进度 52/56）。

本地拿那个数据跑的时候都编译不通，报常量太多 Too many constants, the constant pool for KLengthApartTest would exceed 65536 entries。改成从文件读取输入数据。发现10w数据。

发现上面记录max min的过程，也可以用来计算每一个子集的大小。List 也不需要了。不过改完还是得20秒才能出结果。看来 O(n^2) 是不行的，在一个数组中取顺序的子集，可以用双指针保存子集的范围试试。依旧不行，而且代码越写越丑陋。

看题解，题解说用滑动窗口。也是用双指针指定区间，看来判断如何滑动才是最重要的。





（滑动窗口）**第三版：**

